# Service for serving DLite entities

This is a FastAPI-based REST API service running on onto-ns.com.
It's purpose is to serve DLite entities from an underlying database.

## Run the service

First, download and install the Python package from GitHub:

```shell
# Download (git clone)
git clone https://github.com/CasperWA/dlite-entities-service.git
cd dlite-entities-service

# Install (using pip)
python -m pip install -U pip
pip install -U -e .
```

### Using Docker

For development, start a local MongoDB server, e.g., through another Docker image:

```shell
docker run -d --name "mongodb" -p "27017:27017" mongo:6
```

Then build and run the DLite Entities Service Docker image:

```shell
docker build --pull -t entity-service --target development .
docker run --rm -d \
  --env "entity_service_mongo_uri=mongodb://localhost:27017" \
  --name "entity-service" \
  -p "8000:80" \
  entity-service
```

Now, fill up the MongoDB with valid DLite entities at the `dlite` database in the `entities` collection.

Then go to [localhost:8000/docs](http://localhost:8000/docs) and try out retrieving a DLite entity.

---

For production, use a public MongoDB, and follow the same instructions above for building and running the DLite Entities Service Docker image, but exchange the `--target` value with `production`, put in the proper value for the `entity_service_mongo_uri` environment value, possibly add the `entity_service_mongo_user` and `entity_service_mongo_password` environment variables as well, if needed.

### Using Docker Compose

Run the following commands:

```shell
docker compose pull
docker compose up --build
```

By default the `development` target will be built, to change this, set the `entity_service_docker_target` environment variable accordingly, e.g.:

```shell
entity_service_docker_target=production docker compose up --build
```

Furthermore, the used `localhost` port can be changed via the `PORT` environment variable.

### Using the local environment

Install an ASGI server, like `uvicorn`:

```shell
pip install uvicorn
```

Set some appropriate environment variables to ensure the service can hook up to a desired MongoDB.

Then run it according to your desires.
For example, in development, it might be nice to have the server reload if any files are changed, as well as the server logging debug messages:

```shell
uvicorn dlite_entities_service.main:APP --reload --host localhost --port 8000 --log-level debug --debug --no-server-header --header "Server:DLiteEntitiesService"
```

Then go to [localhost:8000/docs](http://localhost:8000/docs) and try out retrieving a DLite entity.

### Using a file for environment variables

The service supports a "dot-env" file, i.e., a `.env` file with a list of (secret) environment variables.

In order to use this, create a new file named `.env`.
This file will never be committed if you choose to `git commit` any files, as it has been hardcoded into the `.gitignore` file.

Then fill up the `.env` file with secret environment variables.

For using it locally, no changes are needed, as the service will automatically check for a `.env` file and load it in, using it to set the service app configuration.

For using it with Docker, use the `--env-file .env` argument when calling `docker run` or `docker compose up`.

## Testing

The service is tested using `pytest` and can be tested against a local MongoDB server and Entities Service instance or against a mock MongoDB server and Entities Service instance utilizing [Starlette's TestClient](https://fastapi.tiangolo.com/reference/testclient/#test-client-testclient).

To run the tests, first install the test dependencies:

```shell
pip install -U -e .[testing]
```

Then run the tests (for mock MongoDB and Entities Service):

```shell
pytest
```

To run the tests on a live backend, you can pull, build, and run the [Docker Compose file](docker-compose.yml):

```shell
docker compose pull
docker compose build
```

Note, certain environment variables are needed to be set for the local Entity Service for the tests to run.
Set these variables in a local `.env` file:

- `ENTITY_SERVICE_ADMIN_USER` (should be set to `root`)
- `ENTITY_SERVICE_ADMIN_PASSWORD` (should be set to `root`)
- `ENTITY_SERVICE_ADMIN_DB` (should be set to `admin`)

and finally

- `ENTITY_SERVICE_PRIVATE_SSL_KEY`, which should be set to a value as generated by the following command:

```shell
openssl rand -hex 32
```

Then run (up) the Docker Compose file and subsequently the tests:

```shell
docker compose --env-file .env up -d
pytest --live-backend
```

### Extra pytest markers

There are some custom pytest markers:

- `skip_if_live_backend`: skips the test if the `--live-backend` flag is set.
  Add this marker to tests that should not be run against a live backend.
  Either because they are not relevant for a live backend, or because they currently impossible to replicate within a live backend.

  A reason can be specified as an argument to the marker, e.g.:

  ```python
  @pytest.mark.skip_if_live_backend(reason="Cannot force an HTTP error")
  def test_something():
      ...
  ```

  **Availability**: This marker is available for all tests.

- `skip_if_not_live_backend`: skips the test if the `--live-backend` flag is **not** set.
  Add this marker to tests that should only be run against a live backend.
  Mainly due to the fact that the mock backend does not support the test.

  A reason can be specified as an argument to the marker, e.g.:

  ```python
  @pytest.mark.skip_if_not_live_backend(reason="Indexing is not supported by mongomock")
  def test_something():
      ...
  ```

  **Availability**: This marker is available for all tests.

- `no_token`: run test without a mock authentication token set.
  Add this marker to tests that should be run without an automatic mock authentication token set.
  This is useful for testing the service's behaviour when no token is provided or to test letting the service set a token.

  This marker is meant to be used together with the `_use_valid_token` fixture, which will automatically set a valid mock authentication token for a test.
  The `_use_valid_token` fixture is used for all tests by default in the `cli.test_upload` file.

  **Availability**: This marker is only available for tests in the `cli` test module (folder), and sub-modules (sub-folders) therein.

### Extra pytest fixtures

There is one fixture that may be difficult to locate, this is the `parameterized_entity` fixture.
It can be invoked to automatically parameterize a test, iterating over all the valid entities that exist in the [`valid_entities.yaml`](tests/static/valid_entities.yaml) static test file.
It will return one of these entities as a parsed dictionary for each iteration, i.e., within each test.

The fixture is available for all tests.

## Licensing & copyright

All files in this repository are [MIT licensed](LICENSE).  
Copyright by [Casper Welzel Andersen](https://github.com/CasperWA).
